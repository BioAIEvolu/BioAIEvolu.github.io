{"pages":[],"posts":[{"title":"【单细胞转录组15】旧版SingleR 1.0.0的基本使用方法","text":"介绍利用纯细胞类型的参考转录组数据集，对单细胞RNA测序数据进行无偏倚的细胞类型识别，独立推断每个单细胞的细胞来源。 参考注释库小鼠 [[1]] Immunological Genome Project (ImmGen) [[2]] A dataset of 358 mouse RNA-seq samples annotated to 28 cell types. **(对小鼠大脑相关的样本可能很有用） 人类 [[1]]: Human Primary Cell Atlas (HPCA）：个人觉得这个感觉对免疫细胞的注释会稍微准确一些 [[2]]: Blueprint+Encode 对于特定的应用，可以使用更小的数据集(有关巨噬细胞的例子，请参阅主要的论文)。SingleR可以灵活地与任何参考数据集一起使用。 SingleR以两种模式运行 (1) Single-cell:对每个单细胞分别执行注释。 (2) Cluster:在先前定义的Cluster上执行注释，其中Cluster的表达情况是Cluster中所有细胞的总的表达情况。此外，SingleR将细胞/Cluster注释为所有参考细胞类型，或者将参考细胞类型组合为主要细胞类型。 两种Variable genes模式SingleR支持在参考数据集中选择可变基因的模式。 “sd”—参考数据集中所有样本的标准偏差超过阈值的基因。我们选择的阈值是3000-4000个基因。 ‘ de ‘ -在细胞类型中具有较高中位表达的前N个基因。我们使用一个变化的N，这取决于分析中使用的细胞类型的数量。更多细节可以在SingleR代码中找到。（一般都都用这个模式） 创建SingleR对象123456# Generating SingleR+Seurat objectsingler = CreateSinglerSeuratObject(counts = 'GSE74923_series_matrix.txt',annot = 'GSE74923_types.txt', project.name = 'GSE74923', min.genes = 500,min.cells = 2, npca = 10, regress.out ='nUMI', technology= 'C1', species = 'Mouse',citation = 'Kimmerling et al. 2016',reduce.file.size = T, variable.genes = 'de'normalize.gene.length = T) 参数： seurat：Seurat对象(仅当使用相关函数时)。使用reduce.file.size开关将从对象中删除原始数据。 另一个列表，带有针对每个引用数据集的singler注释的数据。列表中的每个元素都是一个包含以下字段的列表 SingleR.single: 所有细胞类型的结果列表 SingleR.single.main：只针对主要细胞类型的 single cells 的结果列表。 SingleR.cluster：按cluster列出所有细胞类型的结果。 SingleR.cluster.main：仅针对主要细胞类型按cluster划分的结果列表。 上述每个元素都包含以下字段(以及其他字段： scores ：汇总分数的矩阵。行是每个细胞(或cluster)，列是每个细胞类型。cell type. labels ： 微调的注释标签。 labels1： 带注释的标签，无需微调(一轮后). signatures：带有ssGSEA分数的数据框，用于预先指定的签名。 meta.data：包含项目名称、原始标识和坐标的列表。 或者不依赖Seurat对象直接创建 1234567# Generating SingleR object without Seurat. To use this SingleR visualization functions# it is necessary to add coordinates for each cell in the field 'singler$meta.data$xy'singler = CreateSinglerObject(counts = 'GSE74923_series_matrix.txt',annot = 'GSE74923_types.txt', project.name = 'GSE74923', min.genes = 500,technology= 'C1', species = 'Mouse',citation = 'Kimmerling et al. 2016',reduce.file.size = T, variable.genes = 'de'normalize.gene.length = T) 实际上操作中，我还是比较少用上面这两种方法，我一般做法都是构建好输入的变量，然后传给函数。 代码示例例子1首先，我们来看看t-SNE图，这是由 original identities 所决定的: 1234567# singler$singler[[1]] is the annotations obtained by using ImmGen dataset as reference.# singler$singler[[2]] is based on the Mouse-RNAseq datasets.out = SingleR.PlotTsne(singler$singler[[1]]$SingleR.single,singler$meta.data$xy, do.label = FALSE, do.letters = F,labels=singler$meta.data$orig.ident,label.size = 4,dot.size = 3)out$p 然后，我们可以通过汇总分数的热图观察分类。这些分数是在微调之前。我们可以看到这个热图的主要细胞类型: 12SingleR.DrawHeatmap(singler$singler[[1]]$SingleR.single.main, top.n = Inf,clusters = singler$meta.data$orig.ident) 或按着所有细胞类型(显示前50细胞类型): 12SingleR.DrawHeatmap(singler$singler[[1]]$SingleR.single, top.n = 50,clusters = singler$meta.data$orig.ident) 可见，L1210细胞被强分为3种类型的B细胞祖细胞。我们可以看到CD8细胞主要与效应CD8+ T细胞的特异性激活相关。有趣的是，有一种细胞似乎同时与pro B细胞和CD8+ T细胞相关，这表明这是一个双重态 这个heatmap的另一个有趣的应用是能够聚集细胞，不是通过它们的基因表达谱，而是通过它们与数据库中所有细胞类型的相似性。 注意：这个视图可能会产生误导，因为每个列都被规范化为0到1之间的分数(这也取决于视图中包含的细胞类型)。因此，单个细胞可能与多种细胞类型的相关性较低，而且它们都不是精确的细胞类型，但在热图中它们都是红色的。没有标准化的数据看起来像这样: 12SingleR.DrawHeatmap(singler$singler[[1]]$SingleR.single,top.n = 50,normalize = F,clusters = singler$meta.data$orig.ident) 接下来，我们可以使用微调标签为t-SNE图上色: 12345out = SingleR.PlotTsne(singler$singler[[1]]$SingleR.single,singler$meta.data$xy,do.label=FALSE,do.letters = F,labels = singler$singler[[1]]$SingleR.single$labels,label.size = 4, dot.size = 3)out$p 其中参考数据集选择依靠的是[[数字]] 我们可以看到SingleR正确地将所有L1210注释为B细胞的类型，几乎完全是B细胞的祖细胞。另一方面，所有CD8细胞都被正确注释为CD8+ t细胞。 重要的是要记住SingleR可以选择253种类型，但是它正确地选择了最相关的细胞类型。有趣的是，tSNE图错误地将细胞定位在错误的簇中，但是SingleR没有受到影响。 最后，相对于原来的identities,我们也可以把标签看作是一个表: 1kable(table(singler$singler[[1]]$SingleR.single$labels,singler$meta.data$orig.ident)) 例子2使用与上述相同的filters运行Seurat产生以下t-SNE图: 12345out = SingleR.PlotTsne(singler$singler[[1]]$SingleR.single, singler$meta.data$xy, do.label = FALSE, do.letters = F,labels = singler$meta.data$orig.ident, dot.size = 1.5)out$p 以及SingleR煮注释(主要细胞类型): 1234out = SingleR.PlotTsne(singler$singler[[1]]$SingleR.single.main,singler$meta.data$xy, do.label = FALSE,do.letters = F, dot.size = 2)out$p SingleR将左侧全部映射为巨噬细胞，右上部分映射为单核细胞，右下部分映射为树突状细胞。 再看看表格 1kable(table(singler$meta.data$orig.ident,singler$singler[[1]]$SingleR.single.main$labels)) 我们选择每种细胞类型的前50个差异表达基因，并给出它们在单个细胞中的表达热点图: 12345678910111213gse62631.de &lt;- read.table(file.path(path,'GSE62361_DE.txt'),header=TRUE, sep=&quot;\\t&quot;, row.names=1, as.is=TRUE)bmdc.genes = gse62631.de[intersect(rownames(gse62631.de),rownames(singler$seurat@data)),'Group',drop=F]d = t(scale(t(as.matrix(singler$seurat@data[rownames(bmdc.genes),]))))d[d&gt;2]=2;d[d&lt; -2]=-2annotation_col = data.frame(Annotation=singler$singler[[1]]$SingleR.single.main$labels)pheatmap(d[order(bmdc.genes$Group),order(singler$singler[[1]]$SingleR.single.main$labels)],cluster_cols = F,cluster_rows = F,clustering_method='ward.D',border_color = NA,annotation_col=annotation_col,annotation_row = bmdc.genes,show_colnames=F,show_rownames=F) 我们可以看到，SingleR正确地识别了树突状细胞和巨噬细胞。有趣的是，标记为单核细胞的细胞似乎同时含有GM-Macs和GM-DCs的标记，这表明这些细胞是早期的祖细胞，尚未与DC或巨噬细胞谱系结合( have not yet committed to the DC or Macrophage lineage) 例子3我们还将SingleR应用于人类数据集。利用10X平台从分选的免疫和细胞系群体中产生了&gt;100K单细胞。我们从https://support.10xgenomics获得该数据。 12345out = SingleR.PlotTsne(singler$singler[[1]]$SingleR.single,singler$meta.data$xy,do.label = FALSE,do.letters = F,labels = singler$meta.data$orig.ident,dot.size = 2)out$p tSNE图可以区分大多数细胞类型，但是 T-cells子集都是难以区分的的。 我们首先看看Seurat的聚类信息: 12345out = SingleR.PlotTsne(singler$singler[[1]]$SingleR.single,singler$meta.data$xy,do.label = T,do.letters = F,labels=singler$seurat@ident,dot.size = 2,label.size = 4)out$p 1kable(table(singler$meta.data$orig.ident,singler$seurat@ident)) 我们可以看到Seurat的表现相对较好;然而，regulatory T-cells完全溶解（dissolved）在memory T-cells的cluster中。 SingleR使用Blueprint+ENCODE (BE)作为参考，在微调之前产生以下注释: 1234# Note the use of the second tiem in the the singler$singler list to use the Blueprint+ENCODE reference.# use singler$singler[[i]]$about for meta-data on the reference.SingleR.DrawHeatmap(singler$singler[[2]]$SingleR.single,top.n=Inf,clusters = singler$meta.data$orig.ident) 我们可以看到，在微调之前， T-cells 状态之间有很强的模糊，这是无法区分的。然而，通过微调，我们得到以下注释: 12345out = SingleR.PlotTsne(singler$singler[[2]]$SingleR.single,singler$meta.data$xy,do.label=FALSE,do.letters =F,labels=singler$singler[[2]]$SingleR.single$labels,dot.size = 1.5, font.size = 6)out$p 1234k = kable(table(singler$singler[[2]]$SingleR.single$labels,singler$meta.data$orig.ident), &quot;latex&quot;)kable_styling(k,font_size=6,bootstrap_options = &quot;striped&quot;,full_width = F) 通过观察颜色我们可以看到,CD4+ T-cell cluster大致可以分为4种状态,从在底部(绿色)的naive CD4+ T-cells,位于中央的记忆和记忆效应 CD4+ T-cells(紫色和橙色),以及在顶部(粉红色)的 Tregs 虽然它不是完美的，但它为我们提供了细胞状态的更细粒度的视图，而不需要检查许多可能根本不在数据中的markers，因此其解释（interpretation）有时令人困惑: 12345678df = data.frame(x=singler$meta.data$xy[,1],y=singler$meta.data$xy[,2],t(as.matrix(singler$seurat@data[c('CD3E','CD4','CD8A','CCR7','GZMA','GNLY','MS4A1','CD14','CD34'),])))df = melt(df,id.vars = c('x','y'))ggplot(df,aes(x=x,y=y,color=value)) +geom_point(size=0.3)+scale_color_gradient(low=&quot;gray&quot;, high=&quot;blue&quot;) +facet_wrap(~variable,ncol=3) +theme_classic()+xlab('')+ylab('') 有趣的是，SingleR提出了一个关于b细胞群的更细致的观点，把它分成naive和 memoryB-cells。 我们可以看到，SingleR在它的 calls 中是相当令人信服的，给予这些细胞较低的单核细胞评分。使用罕见细胞类型的标记(至少在单核细胞分类的细胞中)是有问题的，因为基于标记的分析侧重于cluster而不是单个细胞。 有趣的是，在t-SNE图中，我们看到两个不同的单核细胞簇，显示了使用SingleR聚类的能力。 例子4小鼠器官异质性 12345out = SingleR.PlotTsne(singler$singler[[1]]$SingleR.single.main,singler$meta.data$xy,do.label=FALSE,do.letters =F,labels=singler$singler[[1]]$SingleR.single.main$labels,dot.size = 1, font.size = 8)out$p 我们可以看到，SingleR能够解决细胞的异质性，并允许一个快速和无偏倚的方法来进一步探索该器官的细胞异质性。 SingleR 网页版工具 SingleR web工具包含50个公共可用的scRNA-seq数据集。 所有数据都使用上述工具进行了重新处理，而web工具允许用户立即访问这些数据并对发布的单细胞数据进行进一步的挖掘。 此外，我们邀请用户上传他们自己的scRNA-seq数据，这些数据将在我们的服务器上进行分析，并将处理一个SingleR对象，然后将其上传并在网站上使用(私下里，只有拥有该对象的用户才能查看它)。更多信息请访问http://comphealth.ucsf.edu/SingleR。 新版的SingleR的CreateSinglerObject()改为SingleR(）,用法大体相同，而且多了几个可以下载数据集的函数。 参考文章 https://www.biorxiv.org/content/biorxiv/suppl/2018/03/19/284604.DC1/284604-2.pdf","link":"/2020/02/06/%E3%80%90%E5%8D%95%E7%BB%86%E8%83%9E%E8%BD%AC%E5%BD%95%E7%BB%8415%E3%80%91%E6%97%A7%E7%89%88SingleR-1-0-0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"【爬虫项目(二)】Selenium框架爬取淘宝商品信息","text":"特别声明： 供交流学习使用，不得用作商业用途。 如有违规侵权，请联系删除。一、Selenium框架介绍 Selenium 是一个用于浏览器自动化测试的框架，可以用来爬取任何网页上看到的数据。简单地说，就是模拟一个人所有的网页操作的行为 Selenium的下载与安装: 安装：在终端输入 pip install selenium 下载：下载Chromedriver，解压后放在…\\Google\\Chrome\\Application\\（右击Chrome图标，打开文件所在文件夹） 环境变量：将该目录添加至环境变量：右键点击我的电脑—–&gt;属性—&gt;高级系统设置—-&gt;环境变量——&gt;在path路径下添加上文中…\\Google\\Chrome\\Application\\路径 使用代码测试：Selenium的简单使用： 12345678from selenium import webdriverfrom selenium.webdriver.common.keys import Keysdriver = webdriver.Chrome()driver.get('http://www.baidu.com')elem = driver.find_element_by_xpath('//*[@id = &quot;kw&quot;]') #查找输入框elem.send_keys('Python Selenium',Keys.ENTER) #模拟点击回车print(driver.page_source) 遇到的问题：报错显示缺少参数”Python3 Selenium自动化测试赋值出现：WebDriverException: Message: unknown error: call function result missing ‘value’”，发现的Chromedriver版本要跟当前Chrome版本一致才可以 Chrome版本对应Chromedriver下载地址 Selenium的优缺点: 优点：Selenium可以爬取任何网页的任何内容，因为它是通过浏览器访问的方式进行数据的爬取，没有网站会拒绝浏览器的访问。 但是淘宝和知乎会对Selenium有反爬机制，需要进行伪装。 缺点：时间以及内存消耗太大,可以开启无头模式headless或者PhantomJS webdriver缓解这个问题 二、Selenium的使用跟人操作网页一样，都是需要查找和操作网页元素 查找元素XXX表示用CSS、id、name、identifier、XPath定位、 超链接、DOM、 CSS selector进行定位。更多定位方式PS: 对于网页的定位路径，只需要在谷歌浏览器中，鼠标放到对应元素--右键--检查--在右边的网页源码相应位置--右键--复制--选择相应的路径定位方法 1.直接用webdriver对象的查找1234driver.find_element_by_XXX() 查找符合条件的单个元素 driver.find_elements_by_XXX() 查找符合条件的一组元素 此方法通常需要前面编写time.sleep()一定秒数，让网页加载完毕，否则可能会找不到元素 WebDriverWait对象（更推荐）此方法可以显式等待网页加载显式等待可以自定义等待的条件，用于更加复杂的页面等待条件123456789from selenium import webdriverfrom selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Chrome()driver.get('填入网站的url')wait = WebDriverWait(driver, 10) 构建WebDriverWait对象，10秒加载时间wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, 'CSS选择器定位路径'))) # 很多有经验的selenium用户推荐CSS定位方式，因为它比XPath更快。而且可以在HTML文件中找到更复杂的对象。 使用pyquery库类似JQuery定位元素此方法适合用作返回网页元素进行下一步处理12345678910from selenium import webdriverfrom pyquery import PyQuery as pqdriver = webdriver.Chrome()driver.get('填入网站的url')html = driver.page_source()doc = pq(html)#pyquery(browser.page_source)就相当于requests.get获取的内容items = doc('CSS选择器路径').items() 操作元素相应的，我们有： 直接用webdriver对象的操作123456789from selenium import webdriveraccount = browser.find_element_by_xpath('//*[@id=&quot;TPL_username_1&quot;]')account.clear()account.send_keys(&quot;用户名&quot;)passwd = browser.find_element_by_xpath('//*[@id=&quot;TPL_password_1&quot;]')passwd.send_keys(&quot;密码&quot;)submit = browser.find_element_by_xpath('//*[@id=&quot;J_SubmitStatic&quot;]')submit.click() #点击登录按钮 WebDriverWait对象的操作（更推荐）也是可以显示等待加载时间12345678910from selenium import webdriverfrom selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC input = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; input')))submit = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, '#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; span.btn.J_Submit')))input.clear() # 清除输入框内容input.send_keys(page_num) # 输入输入框内容submit.click() # 点击确定按钮 三、Selenium项目实战（爬取淘宝商品）思路： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#! /usr/bin/env python# -*- coding:utf-8 -*-# Use for get infomation from taobao by ChromeDriver# Author:Robin; Created in 20190831from selenium import webdriverfrom selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC from selenium.common.exceptions import TimeoutException #检查网络请求是否超时#from selenium.webdriver import ChromeOptions#from selenium.webdriver.common.keys import Keys#from selenium.webdriver import ActionChainsfrom pyquery import PyQuery as pq from pymongo import MongoClient#import randomimport timeimport rebrowser = webdriver.Chrome() #创建webdriver对象wait = WebDriverWait(browser, 10) #进入淘宝网，输入商品名称，返回页面def search(good): try: browser.get('https://www.taobao.com/') input = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '#q'))) # 搜索输入框 submit = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '#J_TSearchForm &gt; div.search-button &gt; button'))) # 搜索点击按 keys = '{}'.format(good) input.send_keys(keys) #输入商品名 submit.click() #点击搜索 total = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.total'))) get_products(good) return total.text #总页数 except TimeoutException: #login(browser) search(good) #跳转到下一页def next_page(page_num, good): print('正在爬取第{}页'.format(page_num)) try: input = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; input'))) #页码输入框 submit = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, '#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; span.btn.J_Submit'))) #页码跳转确定按钮 input.clear() #清空页码框 input.send_keys(page_num) #输入页码 submit.click() # 点击确定 time.sleep(10) #防止爬取过快 wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR, '#mainsrp-pager &gt; div &gt; div &gt; div &gt; ul &gt; li.item.active &gt; span'), str(page_num))) #检查是否跳转到正确页数 get_products(good) except TimeoutException: next_page(page_num, good)#得到淘宝商品信息def get_products(good): wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '#mainsrp-itemlist .items .item'))) html = browser.page_source doc = pq(html) # pyquery(browser.page_source)就相当于requests.get获取的内容, 构建PyQuery对象 items = doc('#mainsrp-itemlist .items .item').items() #获取所有的‘#mainsrp-itemlist .items .item’选择出来的内容下的各项 for item in items: # 每个item变量都是一个PyQuery对象，然后再调用它的find()方法，传入CSS选择器，就可以获取单个商品的特定内容了。 products = { 'image': item.find('.pic .img').attr('src'), #获取图片链接 'price': item.find('.price').text(), 'deal': item.find('.deal-cnt').text()[:-3], 'title': item.find('.title').text(), 'shop': item.find('.shop').text(), 'location': item.find('.location').text(), } #print(products) save_to_mongo(products, good)# 保存数据到MongoDBdef save_to_mongo(result, good): client = MongoClient('mongodb://localhost:27017') db = client.taobao set_name = '{}'.format(good) goods_set = db[set_name] # 创建以商品名命名的数据集 try: if goods_set.insert(result): # 插入到MongoDB数据库相应数据集 print(&quot;存储到MONGODB成功&quot;,result) except Exception: print(&quot;存储到MONGODB失败&quot;,result)def main(good): print('正在爬取第1页...') total = search(good) total = int(re.compile('(\\d+)').search(total).group(1)) for i in range(2, total+1): next_page(i, good) browser.close() #把浏览器关掉if __name__ == '__main__': main('树莓派') 运行结果： 问题 淘宝模拟登录： 一开始我以为淘宝点击搜索商品是都会自动跳转到登录页面的，然后就想用Selenium模拟人的登录，然后再利用selenium.webdriver的ActionChains的click_and_hold(slider).perform() 和 click_and_hold(slider).perform() 方法，模拟人操作时候先快后慢的特点 后面才发现淘宝识别的是浏览器发送的一些参数判定是Selenium还是普通浏览器 但是感觉这个代码挺有意思的，或许以后也有用，也拿出来分享下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105from selenium import webdriverfrom selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC from selenium.common.exceptions import TimeoutException #检查网络请求是否超时from selenium.webdriver import ChromeOptionsfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver import ActionChainsfrom pyquery import PyQuery as pq from pymongo import MongoClientimport randomimport timeimport re##选用开发者模式，创建一个浏览器对象，可避免被淘宝检测到是selenium模拟浏览器option = ChromeOptions()option.add_argument('--proxy-serve=127.0.0.1:8080')option.add_experimental_option('excludeSwitches',['enable-automation']) #chrome_options.add_experimental_option('excludeSwitches', ['enable-logging'])#禁止打印日志 跟上面只能选一个browser = webdriver.Chrome(options=option)browser = webdriver.Chrome()wait = WebDriverWait(browser, 10)# 滑块移动轨迹计算：使得滑块先快后慢def get_track(distance): track = [] current = 0 mid = distance * (1/2) t = 2 v = 0 a = 4 a1 = -4 while current &lt; distance: #滑条前1/2的部分加速滑动 if current &lt; mid: move = v * t + 1/2 * a *t * t #物理上匀加速运动计算某一时间内的位移： s = v*t + (1/2)a*t^2 current += move track.append(round(move)) v = v + a*t # 加速运动物体某一时刻的瞬时速度 else: #滑条后1/2的部分加速度减慢 move = v * t + 1/2 * a1 *t *t current += move track.append(round(move)) v = v + a1*t return trackdef drag(length, xpath): if browser.find_element_by_xpath(&quot;{}&quot;.format(xpath)): slider = browser.find_element_by_xpath(&quot;{}&quot;.format(xpath)) #找到滑动按钮 track = get_track(length) #模拟运动轨迹，速度先快后慢 ActionChains(browser).click_and_hold(slider).perform() # 按住滑块滑动 for x in track: ActionChains(browser).drag_and_drop_by_offset(slider, xoffset=x, yoffset=random.randint(1,3)).perform() ActionChains(browser).release().perform() else: pass # Selenium控制的情况下搜索商品，淘宝会自动跳转到登录界面def login(browser): try: button = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '#J_Quick2Static'))) button.click() account = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '#TPL_username_1'))) passwd = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '#TPL_password_1'))) submit = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '#J_SubmitStatic'))) account.clear() account.send_keys('用户名') passwd.send_keys('密码') submit.click() try: change_login = browser.find_element_by_id('J_Quick2Static') #点击密码登录按钮，选择用密码方式登录 time.sleep(3) change_login.click() except Exception: pass time.sleep(3) account = browser.find_element_by_xpath('//*[@id=&quot;TPL_username_1&quot;]') account.clear() account.send_keys('用户名’) passwd = browser.find_element_by_xpath('//*[@id=&quot;TPL_password_1&quot;]') passwd.send_keys('密码') try: drag(700, &quot;//*[@id='nc_1_n1z']&quot;) except Exception: pass submit = browser.find_element_by_xpath('//*[@id=&quot;J_SubmitStatic&quot;]') submit.click() #点击登录按钮 try: index_page = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '//*[@id=&quot;J_SiteNavHome&quot;]/div/a/span'))) index_page.click() except Exception: login(browser) except TimeoutException: login(browser)if __name__ == '__main__': login(browser) 有时候用正则表达式匹配淘宝的页码，total = int(re.compile(‘(\\d+)’).search(total).group(1))会匹配失败，不知道究竟是加载不完全还是淘宝的一些反爬措施，有空再研究下 当爬取到一定页数的时候，淘宝会检查到页面的异常，然后就会卡在验证页面，出现手动也无法通过验证的情况，所以应该要多准备几个代理和IP，使用scrapy框架来爬取会更加方便。改进 由于淘宝对Selenium的反爬做得比较好，所以登录需要手动扫码登录，如果需要模拟登录请参考以下链接： python模拟登陆淘宝（更新版） 如果需要更新MongoDB数据库，请参考： MongoDB 更新文档 Mongodb数据更新命令（update、save） python 更新 MongoDB python与mongodb的交互 增删改差 账号和密码可以存储到json或者pickle打包的配置文件里面，需要时回调，方便代码维护和信息安全 更多Selenium技巧扩展阅读：可以用于掩饰Selenium，防止被识别出设置headless和关闭图片缓存，可以减少机器负荷，提高性能 - chrome配置设置无头浏览器PhantomJS和关闭图片缓存 - Windows下PhantomJS的安装和使用 - Python3网络爬虫开发实战 1.2.5-PhantomJS的安装 - Python爬虫利器四之PhantomJS的用法Selenium更多定位用法： - 菜鸟学自动化测试（五）—–selenium命令之定位页面元素更多CSS选择器用法：（PS：这又是一个大坑） - 【Selenium专题】元素定位之CssSelector - Selectors Level 3官方文档其他参考教程： - 网络爬虫（python项目） - 爬虫实践—Selenium-抓取淘宝搜索商品信息 - (九)使用Selenium+Chrome/PhantomJS(模拟浏览器)抓取淘宝商品美食信息|Python3网络爬虫开发实战","link":"/2020/02/06/%E3%80%90%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE2%E3%80%91Selenium%E6%A1%86%E6%9E%B6%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/02/03/hello-world/"},{"title":"【单细胞转录组8】新版SingleR1.1.1细胞注释包的学习笔记","text":"*SingleR*是用于单细胞RNA测序（scRNAseq）数据的自动注释方法 一、内置数据集下载与加载 用函数下载参考数据集，并返回SummarizedExperiment对象，具有“ logcounts” assay，其中包含对数标准化的表达值以及colData中的细胞类型标签。 人类参考集 从Blueprint和ENCODE获取人类bulk RNA-seq数据。 1BlueprintEncodeData(rm.NA = c(&quot;rows&quot;, &quot;cols&quot;, &quot;both&quot;, &quot;none&quot;)) rm.NA：字符串型，指定应如何处理缺失值。 “rows”将删除具有至少一个缺失值的基因，“ cols”将删除具有至少一个缺失值的样本，“both”将删除任何具有至少一个缺失值的基因或样本，而“none”将不执行任何 去除。 从免疫细胞表达数据库（DICE）下载并缓存已分类细胞群的1561个bulk RNA-seq 1ref.se &lt;- DatabaseImmuneCellExpressionData() 获得HPCA数据。下载并缓存那些存储在人类原代细胞图集Human PrimaryCell Atlas中的数据的标准化表达值。 1ref.se &lt;- HumanPrimaryCellAtlasData() 获得用于分类的造血细胞的bulk微阵列表达。下载并缓存可在GSE24759中找到的211个分类的造血细胞群体的bulk人类微阵列样品的标准化表达值1ref.se &lt;- NovershternHematopoieticData() 获取分类的人类免疫细胞的大量RNA-seq数据。下载并缓存可在GSE107011中找到的分类免疫细胞群的114个bulk RNA-seq样本的标准化表达值。1ref.se &lt;- MonacoImmuneData() 小鼠参考集 从免疫基因组计划中获取小鼠bulk表达数据。下载并缓存由免疫基因组计划（ImmGen）生成的830个纯小鼠免疫细胞微阵列样品的标准化表达值。 1ref.se &lt;- ImmGenData() 获取分类细胞群体的小鼠bulk表达数据（RNA-seq）。下载并缓存可在GEO处找到的358个分类细胞群体的bulk RNA-seq样本的标准化表达值。1ref.se &lt;- MouseRNAseqData() ================================================================ 二、 aggregateReference()作用：整合参考数据集用法12aggregateReference(ref, labels, power = 0.5, assay.type = &quot;logcounts&quot;,check.missing = TRUE) 参数： ref：参考表达式值的数字矩阵，通常包含对数表达式值。 或者，包含此类矩阵的SummarizedExperiment对象。 labels：参考中所有细胞的已知标记的特征向量或因子。 power：0到1之间的数字标量，指示每个数据集被整合的权重，请参阅详细信息。 assay.type：一个整数标量或字符串，如果ref是SummarizedExperiment对象，则指定包含的相关表达式矩阵的ref的数组。 check.missing：逻辑标量，指示是否应检查行的缺失值（如果找到，则将其删除）。细节 对于单细胞参考数据集，将单个细胞聚合为伪大量样本以用作参考通常很有用。 例子12345678910library(scater)sce &lt;- mockSCE()sce &lt;- logNormCounts(sce)# Making up some labels for demonstration purposes:labels &lt;- sample(LETTERS, ncol(sce), replace=TRUE)# Aggregation at different resolutions:(aggr &lt;- aggregateReference(sce, labels, power=0.5))(aggr &lt;- aggregateReference(sce, labels, power=0))# No aggregation:(aggr &lt;- aggregateReference(sce, labels, power=1)) 三、matchReferences()作用 匹配来自两个参考的标签。匹配来自一对引用的标签，这些标签对应于相同的基础细胞类型或状态，但名称有所不同。 用法1matchReferences(ref1, ref2, labels1, labels2, ...) 参数 ref1, ref2:单细胞（通常是对数转换）表达值的数值矩阵，其中行是基因，列是细胞。 或者，包含此类矩阵的SummarizedExperiment对象 labels1, labels2:ref1和ref2中所有细胞的已知标记的特征向量或因子。 …：Further arguments to pass to SingleR.返回值包含相互分配的概率表的数字矩阵。 接近1的值表示两个reference之间的标签之间的1：1映射。例子123example(SingleR, echo=FALSE)test$label &lt;- paste0(test$label, &quot;_X&quot;) # modifying the labels.matchReferences(test, ref, labels1=test$label, labels2=ref$label) 四、 classifySingleR()例子1ref.se &lt;- BlueprintEncodeData(rm.NA = &quot;rows&quot;) 使用预先训练的包含迭代微调方法的分类器，将标签分配给测试数据集中的每个细胞。(PS:说人话，就是用来分类细胞的） 用法：1234classifySingleR(test, trained, quantile = 0.8, fine.tune = TRUE,tune.thresh = 0.05, sd.thresh = NULL, prune = TRUE,assay.type = &quot;logcounts&quot;, check.missing = TRUE,BPPARAM = SerialParam()) 参数： test： 单细胞表达值的数字矩阵，其中行是基因，列是细胞。或者，包含此类矩阵的SummarizedExperiment对象。 trained：一个列表，其中包含trainSingleR函数的输出。 quantile：一个数字标量，指定相关分布的分位数，用于计算每个标签的分值。 fine.tune：指示是否应执行微调的逻辑标量。 tune.thresh：一个数字标量，指定与微调中使用的最大相关值之间的最大差。 sd.thresh：一个数字标量，指定标准偏差的阈值，用于微调过程中的基因选择。 prune：逻辑标量，指示是否应执行标签修剪label pruning。 assay.type：如果test为SummarizedExperiment，则使用整数标量或字符串指定要使用的表达式值矩阵。 check.missing：逻辑标量，指示是否应检查行的缺失值（如果找到，则将其删除）。 BPPARAM：BiocParallelParam对象指定要使用的并行化方案。细节： 仅出于与trainSingleR的一致性，将默认assay.type设置为“ logcounts”。 实际上，也可以使用原始计数（用于UMI数据）或笔录计数（用于读取计数数据），而无需进行标准化和对数转换。 除了因数值引起的一些细微差异外，任何单调变换都不会影响相关值的计算精确。 返回值 每个行都对应于测试集中的细胞的DataFrame。 如果fine.tune = FALSE，则字段为：- **scores**，是每个细胞（行）中每个标签（列）在指定分位数处的相关性数字矩阵。 - **labels**：一个字符向量，其中包含基于得分最高条目的预测标签。 - **prune.scores**：包含修剪标签的字符向量，其中“低质量”标签被替换为NA。 仅在prune = TRUE时添加。 如果fine.tune = TRUE，则字段为：- **scores**：同上 - **tuned.scores**：包含第一个和第二个的DataFrame。 这些是在每个细胞的最后一轮微调中包含最佳和次佳分数的数值向量。 - **labels**：微调后包含预测标签的字符向量。 - **prune.scores**：如上所述的修剪标签的字符向量。 仅在prune = TRUE时添加。 在这两种情况下，DataFrame的元数据都包含：- **common.genes**：在微调之前用于计算相关性的基因的特征向量。 - **de.genes**：用于区分每对标记的基因列表。 仅当在构建训练集时genes =“ de”才返回，有关更多详细信息，请参见 ?trainSingleR。例子123456789101112131415161718192021222324252627282930313233################################ Mocking up training data ################################Ngroups &lt;- 5Ngenes &lt;- 1000means &lt;- matrix(rnorm(Ngenes*Ngroups), nrow=Ngenes)means[1:900,] &lt;- 0colnames(means) &lt;- LETTERS[1:5]g &lt;- rep(LETTERS[1:5], each=4)ref &lt;- SummarizedExperiment(list(counts=matrix(rpois(1000*length(g),lambda=10*2^means[,g]), ncol=length(g))),colData=DataFrame(label=g))rownames(ref) &lt;- sprintf(&quot;GENE_%s&quot;, seq_len(nrow(ref)))ref &lt;- scater::logNormCounts(ref)trained &lt;- trainSingleR(ref, ref$label)################################# Mocking up some test data #################################N &lt;- 100g &lt;- sample(LETTERS[1:5], N, replace=TRUE)test &lt;- SummarizedExperiment(list(counts=matrix(rpois(1000*N, lambda=2^means[,g]), ncol=N)),colData=DataFrame(label=g))rownames(test) &lt;- sprintf(&quot;GENE_%s&quot;, seq_len(nrow(test)))test &lt;- scater::logNormCounts(test)################################# Performing classification #################################pred &lt;- classifySingleR(test, trained)table(predicted=pred$labels, truth=g) 五、getDeltaFromMedian()作用计算每个细胞的增量值，该增量值为：已分配标签的得分与所有标签的和中位数and median 得分之间的差用法1getDeltaFromMedian(results) Arguments results: 一个DataFrame，其中包含SingleR或classifySingleR生成的输出。细节对于想要应用更多自定义过滤器或可视化的用户，此函数计算与pruneScores中使用的相同的增量值。 返回值 一个数字向量，其中包含结果中每个细胞的增量值。 例子123# Running the SingleR() example.example(SingleR, echo=FALSE)summary(getDeltaFromMedian(pred)) 六、plotScoreDistribution()绘制标签的分值分布。 用法12345plotScoreDistribution(results, show = c(&quot;delta.med&quot;, &quot;delta.next&quot;,&quot;scores&quot;), labels = colnames(results$scores), size = 0.5, ncol = 5,dots.on.top = TRUE, this.color = &quot;#F0E442&quot;,pruned.color = &quot;#E69F00&quot;, other.color = &quot;gray60&quot;,show.nmads = NULL, show.min.diff = NULL) 参数 results：包含SingleR或classifySingleR的输出的DataFrame。 show：字符串，指定是否显示分打分。与中位数的差还是与下一个最佳分数的差。 labels：指示要显示的一个或多个标签的字符串向量。 如果为NULL，则显示结果中所有可用的标签。 size：数字标量，用于设置点的大小。 ncol：整数标量，用于设置每行显示的标签数。 dots.on.top:逻辑指定是否在小提琴图的上方绘制细胞点。 this.color：字符串，用于指定分配给标签的细胞的颜色。 pruned.color：字符串，用于指定分配给标签但已修剪的细胞的颜色。 other.color：字符串，用于指定未分配给标签的其他细胞的颜色。 show.nmads：数字标量，显示使用pruneScores进行修剪的阈值。 仅在show =“ delta.med”时使用。 show.min.diff：数字标量，显示使用pruneScores进行修剪的阈值。 仅在show =“ delta.med”或“ delta.next”时使用。细节此函数可创建一个抖动图和小提琴图，以显示一个或多个标签上所有细胞的分配得分或相关值。返回值ggplot对象，显示小提琴图中的分配的打分。例子12345678910111213141516171819202122example(SingleR, echo=FALSE)# To show the distribution of scores grouped by label:plotScoreDistribution(results = pred)# We can display a particular label using the labelplotScoreDistribution(results = pred, labels = &quot;B&quot;)# To show the distribution of deltas between cells' maximum and median scores,# grouped by label, change `show` to &quot;delta.med&quot;:# This is useful for checking/adjusting nmads and min.diff.medplotScoreDistribution(results = pred, show = &quot;delta.med&quot;)# The nmads cutoff can be displayed using show.nmads.plotScoreDistribution(results = pred, show = &quot;delta.med&quot;,show.nmads = 3)# A min.diff.med cutoff can be shown using show.min.diffplotScoreDistribution(results = pred, show = &quot;delta.med&quot;,show.min.diff = 0.03)# To show the distribution of deltas between cells' top 2 fine-tuning scores,# grouped by label, change `show` to &quot;delta.next&quot;:# This is useful for checking/adjusting min.diff.nextplotScoreDistribution(results = pred, show = &quot;delta.next&quot;)# A min.diff.med cutoff can be shown using show.min.diffplotScoreDistribution(results = pred, show = &quot;delta.next&quot;,show.min.diff = 0.03) 七、plotScoreHeatmap()作用创建所有细胞标签组合的SingleR分配打分的热图。 用法12345plotScoreHeatmap(results, cells.use = NULL, labels.use = NULL,clusters = NULL, show.labels = FALSE, show.pruned = FALSE,max.labels = 40, normalize = TRUE, cells.order = NULL,order.by.clusters = FALSE, annotation_col = NULL,show_colnames = FALSE, ...) 参数 results：包含SingleR或classifySingleR的输出的DataFrame。 cells.use：整数或字符串向量，指定要显示的单个细胞的。 如果为NULL，则显示所有细胞。 labels.use：指示要显示哪些标签的字符串向量。 如果为NULL，则显示结果中所有可用的标签。 clusters：包含细胞cluster分配的字符串矢量或因子，将在热图中以注释条显示。 show.labels：逻辑值，指示是否应将细胞的最终标签显示为注释条。 show.pruned：逻辑值，指示标签的修剪状态是否应显示为注释条，正如pruneScores所定义。 max.labels：整数标量，指定要显示的最大标签数。 normalize：逻辑指定是否应将相关系数归一化为[0，1]。 cells.order：整数向量，指定热图的细胞/列的顺序。 不论cells.use，此输入的长度应与细胞总数相同。 如果设置，则关闭基于评分的列聚类。 order.by.clusters：逻辑标量，指定是否应按聚类而不是分数对细胞进行排序。 如果设置，则优先于cells.order输入。 annotation_col, show_colnames, …：传递给了pheatmap的用于热图控制的其他参数。####### 返回值在当前的图形设备上使用pheatmap生成分配分数的热图。颜色归一化(略）例子1234567891011121314151617181920# Running the SingleR() example.example(SingleR, echo=FALSE)# Grab the original identities of the cells as mock clustersclusts &lt;- g# Creating a heatmap that shows cells showed.plotScoreHeatmap(pred)# Creating a heatmap with clusters displayed.plotScoreHeatmap(pred, clusters=clusts)# Creating a heatmap with labels displayed.plotScoreHeatmap(pred, show.labels = TRUE)# Creating a heatmap with whether cells were pruned displayed.plotScoreHeatmap(pred, show.pruned = TRUE)# We can also turn off the normalization with Normalize = FALSEplotScoreHeatmap(pred, clusters=clusts, normalize = FALSE)# To only show certain labels, you can use labels.use or max.labelsplotScoreHeatmap(pred, clusters=clusts, labels.use = c(&quot;A&quot;,&quot;B&quot;,&quot;D&quot;))plotScoreHeatmap(pred, clusters=clusts, max.labels = 4)# We can pass extra tweaks the heatmap as wellplotScoreHeatmap(pred, clusters=clusts, fontsize.row = 9)plotScoreHeatmap(pred, clusters=clusts, cutree_col = 3) 八、pruneScores()作用修剪低质量的assignments。删除根据classifySingleR返回的cell-label打分矩阵的低质量assignments。用法12pruneScores(results, nmads = 3, min.diff.med = -Inf,min.diff.next = 0, get.thresholds = FALSE) 参数 results:包含着SingleR或classifySingleR生成的输出的DataFrame。 nmads：数字标量，用于指定在每个标签的增量值分布（即与中位数的差）中定义较低离群值的MAD数值。 min.diff.med：数字标量，指定每个细胞的最小可接受增量。 min.diff.next：数字标量，指定微调中最佳分数和次佳分数之间的最小差。 get.thresholds：逻辑标量，指示是否应返回增量上的每个标签的阈值。细节 就其本身而言，SingleR算法将始终为每个细胞分配标签。即使该细胞的真实标签未在参考标签集中表示，也会发生这种情况，从而导致对该细胞分配了错误的标签。 pruneScores函数旨在通过消除得分较低的低质量分配来减轻这种影响。 返回值 默认情况下会返回逻辑向量，该逻辑向量指定应忽略结果中的哪些分配。 如果get.thresholds = TRUE，则返回一个数字向量，其中包含增量上每个标签的阈值，这是使用基于异常值的nmads方法定义的。在增量上应用硬过滤器hard filter 如果指定了min.diff.med，则丢弃增量低于此阈值的细胞。在这种情况下，可以设置最小差异阈值以强制删除低得分细胞。 每个标签的增量分布可能是多峰的，但仍然是正确的。在这种情况下，最好设置nmads = Inf并依靠min.diff.med进行过滤。 请注意，增量不会考虑微调的影响，因为分数在不同的微调步骤之间不具有可比性。基于微调分数过滤 如果执行了微调以生成结果，则我们将忽略其微调得分不大于下一个最佳分数min.diff.next的任何细胞。 下一个最 min.diff.next在[0，0.1]之间。 就是说， min.diff.next阈值在涉及高度相关标签的某些应用中可能是有害的。 例子Running the SingleR() example.12345678910example(SingleR, echo=FALSE)summary(pruneScores(pred))pruneScores(pred, get.thresholds=TRUE)# Less stringent:summary(pruneScores(pred, min.diff.med=0))summary(pruneScores(pred, nmads=5))# More stringent:summary(pruneScores(pred, min.diff.med=0.1))summary(pruneScores(pred, nmads=2))summary(pruneScores(pred, min.diff.next=0.1)) 九、 SingleR(）作用注释scRNA-seq数据。给定相同特征空间中的标记参考数据集，返回测试数据集中每个细胞的最佳注释。用法123456SingleR(test, ref, labels, method = c(&quot;single&quot;, &quot;cluster&quot;),clusters = NULL, genes = &quot;de&quot;, quantile = 0.8, fine.tune = TRUE,tune.thresh = 0.05, sd.thresh = 1, prune = TRUE,assay.type.test = &quot;logcounts&quot;, assay.type.ref = &quot;logcounts&quot;,check.missing = TRUE, BNPARAM = KmknnParam(),BPPARAM = SerialParam()) 参数 test：single-cell表达值的数字矩阵，其中行是基因，列是细胞。 或者，包含此类矩阵的SummarizedExperiment对象。 ref： reference expression值的数字矩阵（通常是对数转换，请参阅trainSingleR）。 它应具有与测试中相同的行或其中一部分。或者，包含此类矩阵的SummarizedExperiment对象。 labels：参考中已知标签的所有样本的字符向量或的因子。 method：字符串，用于指定是在测试中的单个细胞上执行注释，还是在注释之前将其聚合到群集级配置文件cluster-level profiles中。 clusters：测试集中每个细胞的字符向量character vector或cluster标识因子。 仅在method =“ cluster”时使用。 genes, sd.thresh:控制用于注释的基因的参数，请参见trainSingleR。 quantile, fine.tune, tune.thresh, prune:传递给classifySingleR的更多参数。 assay.type.test:一个整数标量或字符串，如果测试集是SummarizedExperiment对象，则指定包含相关表达式矩阵的测试集的assay。 assay.type.ref：一个整数标量或字符串，如果ref是SummarizedExperiment对象，则指定包含相关表达式矩阵的ref的assay。 check.missing：逻辑标量，指示是否应检查行的缺失值（如果找到，则将其删除）。 BNPARAM：一个BiocNeighborParam对象，该对象指定用于构建最近邻居索引的算法。 BPPARAM：BiocParallelParam对象，指定应如何执行并行化（如果有）。细节 如果method =”single”，则此函数实际上只是trainSingleR和classifySingleR的便捷包装。 如果method =”cluster”，则对per-cell profiles求和以获得 per-cluster profiles，并在这些cluster上执行注释。 该功能将自动将分析限制为参考和测试中可用的基因的交集。 如果此交集为空（例如，因为两个数据集在其行名中使用不同的注释），则会引发错误。 ref可以包含单个细胞数据或bulk数据，但对于前者，请阅读?trainSingleR中的注释。返回值返回一个DataFrame，其中包含每个细胞或cluster（行）的注释统计信息。 这与classifySingleR的输出相同。####### 例子123456789101112131415161718192021222324252627282930313233343536################################ Mocking up training data ################################Ngroups &lt;- 5Ngenes &lt;- 1000means &lt;- matrix(rnorm(Ngenes*Ngroups), nrow=Ngenes)means[1:900,] &lt;- 0colnames(means) &lt;- LETTERS[1:5]g &lt;- rep(LETTERS[1:5], each=4)ref &lt;- SummarizedExperiment(list(counts=matrix(rpois(1000*length(g),lambda=10*2^means[,g]), ncol=length(g))),colData=DataFrame(label=g))rownames(ref) &lt;- sprintf(&quot;GENE_%s&quot;, seq_len(nrow(ref)))ref &lt;- scater::logNormCounts(ref)trained &lt;- trainSingleR(ref, ref$label)################################# Mocking up some test data #################################N &lt;- 100g &lt;- sample(LETTERS[1:5], N, replace=TRUE)test &lt;- SummarizedExperiment(list(counts=matrix(rpois(1000*N, lambda=2^means[,g]), ncol=N)),colData=DataFrame(label=g))rownames(test) &lt;- sprintf(&quot;GENE_%s&quot;, seq_len(nrow(test)))test &lt;- scater::logNormCounts(test)################################# Performing classification #################################pred &lt;- SingleR(test, ref, labels=ref$label)table(predicted=pred$labels, truth=g)pred2 &lt;- SingleR(test, ref, labels=ref$label,method=&quot;cluster&quot;, clusters=test$label)table(predicted=pred2$labels, truth=rownames(pred2)) 十、trainSingleR作用在具有已知标签的参考数据集上训练SingleR分类器。用法123trainSingleR(ref, labels, genes = &quot;de&quot;, sd.thresh = 1, de.n = NULL,assay.type = &quot;logcounts&quot;, check.missing = TRUE,BNPARAM = KmknnParam()) 参数 ref：表达值的数字矩阵，其中行是基因，列是参考样本（单个细胞或bulk样本）。 这些 expression values应进行对数转换，请参阅“详细信息”。 或者，包含此类矩阵的SummarizedExperiment对象。 labels：参考中所有样本的字符向量或已知标签的因子。 genes：一个字符串，指定要使用的特征feature选择方法，请参见“详细信息”。可选地，在标签对pairs of labels之间包含DE基因的字符向量的列表。或者，包含每个标签的marker基因的字符向量列表。 *sd.thresh *:一个数字标量，指定每个基因的标准偏差的最小阈值。 仅在genes =”sd”时使用。 de.n：一个整数标量，指定genes =”de”时要使用的DE基因的数量。 默认值为500 *（2/3）^ log2（N），其中N是唯一标签的数量。 assay.type:一个整数标量或字符串，如果ref是SummarizedExperiment对象，则指定包含相关表达式矩阵的ref的assay。 check.missing: 逻辑标量，指示是否应检查行的缺失值（如果找到，则将其删除）。 BNPARAM：一个BiocNeighborParam对象，该对象指定用于构建最近邻居索引的算法。细节几个选项可用于功能选择： genes=”de”：识别在标签之间差异表达的基因 genes=”sd：识别在标签之间变化很大的基因。 genes=”all”：将不会执行任何功能选择。如果genes =”de”或”sd”，则 expression values 应是对数转换和归一化后的。或者，基因可以是字符向量的命名列表：12345genes &lt;- list(A = list(A = character(0), B = &quot;GENE_1&quot;, C = c(&quot;GENE_2&quot;, &quot;GENE_3&quot;)),B = list(A = &quot;GENE_100&quot;, B = character(0), C = &quot;GENE_200&quot;),C = list(A = c(&quot;GENE_4&quot;, &quot;GENE_5&quot;), B = &quot;GENE_5&quot;, C = character(0))) 如果我们考虑条目基因$A $B，它包含标签“ A”相对于标签“ B”的marker基因。 即，与“ B”相比，这些基因在“ A”中被上调。 每个标签的外部列表应具有一个列表，每个标签的内部列表应具有一个字符向量。 （显然，标签本身不能带有标记markers，因此将其设置为character(0)。） 或者，基因可以是字符向量的命名列表： 12345genes &lt;- list(A = c(&quot;GENE_1&quot;, &quot;GENE_2&quot;, &quot;GENE_3&quot;),B = c(&quot;GENE_100&quot;, &quot;GENE_200&quot;),C = c(&quot;GENE_4&quot;, &quot;GENE_5&quot;)) 返回值包含以下内容的列表： common.genes：通过feature selection方法选择的所有基因的字符向量 nn.indices：BiocNeighborIndex对象的列表，其中包含预先构造的邻居搜索索引。 original.exprs：数字矩阵的列表，其中每个矩阵都包含特定标签的所有细胞。 extra：有关 feature selection的其他信息的列表，供classifySingleR使用。这包括基因中的选择方法以及在分类过程中可以重复使用的方法特定结构。关于单细胞参考的注意事项 默认marker选择基于中位数的对数倍变化，并且在设计时要考虑bulk参考。 对于单细胞参考数据来说，零计数超过50％的情况并不罕见，这方法可能并不有效。 建议用户要么汇总其单细胞参考以创建pseudo-bulk samples，要么在外部检测markers并将markers列表传递给基因（请参见示例）例子1234567891011121314151617181920212223242526272829################################ Mocking up training data ################################Ngroups &lt;- 5Ngenes &lt;- 1000means &lt;- matrix(rnorm(Ngenes*Ngroups), nrow=Ngenes)means[1:900,] &lt;- 0colnames(means) &lt;- LETTERS[1:5]g &lt;- rep(LETTERS[1:5], each=4)ref &lt;- SummarizedExperiment(list(counts=matrix(rpois(1000*length(g),lambda=10*2^means[,g]), ncol=length(g))),colData=DataFrame(label=g))rownames(ref) &lt;- sprintf(&quot;GENE_%s&quot;, seq_len(nrow(ref)))########################## Doing the training ########################### Normalizing and log-transforming for automated marker detection.ref &lt;- scater::logNormCounts(ref)trained &lt;- trainSingleR(ref, ref$label)trainedtrained$nn.indiceslength(trained$common.genes)# Alternatively, computing and supplying a set of label-specific markers.by.t &lt;- scran::pairwiseTTests(assay(ref, 2), ref$label)markers &lt;- scran::getTopMarkers(by.t[[1]], by.t[[2]], n=10)trained &lt;- trainSingleR(ref, ref$label, genes=markers)length(trained$common.genes)","link":"/2020/02/06/%E3%80%90%E5%8D%95%E7%BB%86%E8%83%9E%E8%BD%AC%E5%BD%95%E7%BB%848%E3%80%91%E6%96%B0%E7%89%88SingleR1-1-1%E7%BB%86%E8%83%9E%E6%B3%A8%E9%87%8A%E5%8C%85%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"'个人博客搭建_1：Github+Hexo+Icarus主题选择'","text":"个人博客搭建(一)：Github+Hexo+Icarus主题优化 环境说明： Win10 已经安装和配置好git 已经有github账号了，本地windows的git环境已经配置好了 npm已经有了 检查： 123git versionnode -vnpm -v 第一步 环境准备 安装 NodeJS 一路next下去安装即可 安装Hexo1npm install -g hexo-cli 第二步 创建github repository repository的命名必须是: 自己的github用户名.github.io 然后在本地目录中新建一个目录,然后构建这个目录与github的repository的联系 第三步 用hexo框架搭建个人博客 进入在上面的git初始化后的目录 运行123hexo init myBlogcd myBlognpm install 新建完成后，指定文件夹的目录如下：123456789&gt; dir .\\.├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json├── scaffolds # 模版文件夹├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹| ├── _drafts # 草稿文件| └── _posts # 文章Markdowm文件 └── themes # 主题文件夹 如果没有报错，继续运行：123hexo s #或者 hexo server 在浏览器中输入 http://localhost:4000 回车就可以预览效果了。第四步 主题个性化 此处选择的主题是：icarus 进入themes文件夹12&gt; cd themes&gt; git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 设置主题的个性化设置：（先跳过）第五步 将hexo的网页部署到 Github 修改配置，在 _config.yml文件下修改以下内容1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 'git' repo: github: https://github.com/BioAIEvolu/BioAIEvolu.github.io.git #新建仓库地址 branch: master #published 安装一个部署插件 hexo-deployer-git1npm install hexo-deployer-git --save 上传到github，以下 g 是 generate 缩写，d 是 deploy 缩写：1hexo g -d 在浏览器访问网址： https://你的用户名.github.io 就会看到你的博客 第六步 用VScode编写Markdown文章并上传 打开VScode,安装插件”Markdown Preview enhanced” 新建文章：在cmd输入命令12345&gt; hexo new '创建个人博客'=============================================INFO Checking dependenciesINFO Validating the configuration fileINFO Created: D:\\Data\\blog\\myblog\\source\\_posts\\创建个人博客.md 用VScode打开文件D:\\Data\\blog\\myblog\\source\\_posts\\创建个人博客.md 本地检查12hexo ghexo s 部署到Github 12hexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g -d 参考文章 https://segmentfault.com/a/1190000017986794 https://blog.csdn.net/marvine/article/details/89816846 https://blog.csdn.net/Fzidx/article/details/99185663 https://github.com/ppoffice/hexo-theme-icarus https://www.cnblogs.com/KongkOngL/p/10449269.html","link":"/2020/02/06/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-1%EF%BC%9AGithub-Hexo-Icarus%E4%B8%BB%E9%A2%98%E9%80%89%E6%8B%A9/"},{"title":"【单细胞转录组9】新版SingleR1.1.1细胞注释的代码实操","text":"函数与参数请参考：单细胞转录组（八）新版SingleR1.1.1细胞注释包的学习笔记 一、使用内置参考集下载参考数据集*SingleR*通过专用的数据检索功能提供了多个参考数据集（主要来自大量RNA-seq或微阵列数据）。例如，要从人类原代细胞图集获取参考数据： 12library(SingleR)hpca.se &lt;- HumanPrimaryCellAtlasData() 这时候这个函数HumanPrimaryCellAtlasData()，会自动下载这个参考基因组序列 12345678910111213&gt; hpca.se &lt;- HumanPrimaryCellAtlasData()C:\\Users\\ADMINI~1\\AppData\\Local\\ExperimentHub\\ExperimentHub\\Cache does not exist, create directory? (yes/no): yes |===========================================================================================================================================| 100%snapshotDate(): 2019-10-22see ?SingleR and browseVignettes('SingleR') for documentationdownloading 1 resourcesretrieving 1 resource |===========================================================================================================================================| 100%loading from cache 加载参考集 123456789&gt; hpca.seclass: SummarizedExperiment dim: 19363 713 metadata(0):assays(1): logcountsrownames(19363): A1BG A1BG-AS1 ... ZZEF1 ZZZ3rowData names(0):colnames(713): GSM112490 GSM112491 ... GSM92233 GSM92234colData names(2): label.main label.fine PS: 因为它的参考数据集只保存到cache里，也就是说每次想要相应的参考集都需要用相应的函数从互联网中下载这个数据集。而对于不能联网的服务器来说，这种方法显然比较麻烦。 加载测试数据集在SingleR()函数中使用此引用来注释La Manno等人的scRNA-seq数据集（2016）的前100个细胞 其中有2个scRNAseq数据集的R包需要安装 123456if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;)BiocManager::install(&quot;scRNAseq&quot;)BiocManager::install(&quot;scater&quot;)BiocManager::install(&quot;scran&quot;) 代码： 123library(scRNAseq)hESCs &lt;- LaMannoBrainData('human-es')hESCs &lt;- hESCs[,1:100] #前100个细胞 输出： 12345678910111213141516&gt; library(scRNAseq) &gt; hESCs &lt;- LaMannoBrainData('human-es') #import dataset |============================================================================| 100%snapshotDate(): 2019-10-22see ?scRNAseq and browseVignettes('scRNAseq') for documentationloading from cachesee ?scRNAseq and browseVignettes('scRNAseq') for documentationloading from cache&gt; hESCs &lt;- hESCs[,1:100] #前100个细胞&gt; # Restrict to common genes between test and reference data:&gt; common &lt;- intersect(rownames(hESCs), rownames(hpca.se))&gt; hpca.se &lt;- hpca.se[common,]&gt; hESCs &lt;- hESCs[common,]&gt; hESCs &lt;- logNormCounts(hESCs) 限制到测试集和参考集的共同基因 123456# Restrict to common genes between test and reference data:library(scater)common &lt;- intersect(rownames(hESCs), rownames(hpca.se))hpca.se &lt;- hpca.se[common,]hESCs &lt;- hESCs[common,]hESCs &lt;- logNormCounts(hESCs) #对数标准化 创建SingleR对象 12345678910111213141516171819202122232425262728293031323334353637383940414243&gt; pred.hpca &lt;- SingleR(test = hESCs, ref = hpca.se, labels = hpca.se$label.main)&gt; pred.hpcaDataFrame with 100 rows and 5 columns scores &lt;matrix&gt;1772122_301_C02 0.118426779945786:0.179699807625087:0.157326274226517:...1772122_180_E05 0.129708246318855:0.236277439793527:0.202370888668263:...1772122_300_H02 0.158201338525345:0.250060222727419:0.211831550178353:...1772122_180_B09 0.158778546217777:0.27716592787528:0.222681369744636:...1772122_180_G04 0.138505219642345:0.236658649096383:0.19092437361406:...... ...1772122_299_E07 0.145931041885859:0.241153701803065:0.217382763112476:...1772122_180_D02 0.122983434596168:0.239181076829949:0.181221997276501:...1772122_300_D09 0.129757310468164:0.233775092572195:0.196637664917917:...1772122_298_F09 0.143118885460347:0.262267367714562:0.214329641867196:...1772122_302_A11 0.0912854247387272:0.185945405472165:0.139232371863794:... first.labels tuning.scores &lt;character&gt; &lt;DataFrame&gt;1772122_301_C02 Neuroepithelial_cell 0.18244020296249:0.09911156529971921772122_180_E05 Neuroepithelial_cell 0.137548373236792:0.06471337346673841772122_300_H02 Neuroepithelial_cell 0.275798157639906:0.1369690401464441772122_180_B09 Neuroepithelial_cell 0.0851622797320583:0.08198784524250981772122_180_G04 Neuroepithelial_cell 0.198841544187094:0.101662168246495... ... ...1772122_299_E07 Neuroepithelial_cell 0.176002520599547:0.09225038236563981772122_180_D02 Neuroepithelial_cell 0.196760862365318:0.1124804862194381772122_300_D09 Neuroepithelial_cell 0.0816424287822026:0.02213680183633021772122_298_F09 Neuroepithelial_cell 0.187249853552379:0.06718928352664231772122_302_A11 Neuroepithelial_cell 0.156079956344163:0.105132159755961 labels pruned.labels &lt;character&gt; &lt;character&gt;1772122_301_C02 Neuroepithelial_cell Neuroepithelial_cell1772122_180_E05 Neurons Neurons1772122_300_H02 Neuroepithelial_cell Neuroepithelial_cell1772122_180_B09 Neuroepithelial_cell Neuroepithelial_cell1772122_180_G04 Neuroepithelial_cell Neuroepithelial_cell... ... ...1772122_299_E07 Neuroepithelial_cell Neuroepithelial_cell1772122_180_D02 Neuroepithelial_cell Neuroepithelial_cell1772122_300_D09 Neuroepithelial_cell Neuroepithelial_cell1772122_298_F09 Neuroepithelial_cell Neuroepithelial_cell1772122_302_A11 Astrocyte Astrocyte 输出的DataFrame每一行都包含单个细胞的预测结果。 在微调（first.labels）之前，fine-tuning (labels) 之后，和pruning (pruned.labels)之后，显示标签以及相关的得分。 我们总结了标记在我们的细胞子集中的分布：[6〜 123&gt; table(pred.hpca$labels)Astrocyte Neuroepithelial_cell Neurons 14 81 5 在这一点上，值得注意的是*SingleR*与工作流/程序包无关。上面的示例使用SummarizedExperiment对象，但是相同的函数将接受任何（对数）规范化的表达矩阵。 二、使用 single-cell references 设置数据：在这里，我们将使用来自*scRNAseq软件包的两个人类胰腺数据集。目的是*使用一个预先标记的数据集注释另一个未标记的数据集**。首先，我们建立了Muraro等人（2016）数据集作为我们的参考。1234567891011121314151617181920&gt; library(scRNAseq)&gt; sceM &lt;- MuraroPancreasData() |============================================================================| 100%snapshotDate(): 2019-10-22see ?scRNAseq and browseVignettes('scRNAseq') for documentation Error: failed to load resource name: EH2692 title: Muraro pancreas counts reason: Recv failure: Connection was reset&gt; &gt; # One should normally do cell-based quality control at this point, but for&gt; # brevity's sake, we will just remove the unlabelled libraries here.&gt; sceM &lt;- sceM[,!is.na(sceM$label)]&gt; table(sceM$label) acinar alpha beta delta duct endothelial epsilon 219 812 448 193 245 21 3 mesenchymal pp unclear 80 101 4 对数规范化：1sceM &lt;- logNormCounts(sceM) 然后，我们从Grun等人的结果中（2016）建立我们的测试数据集。为了加快演示速度，我们前100个细胞的子集。1234sceG &lt;- GrunPancreasData()sceG &lt;- sceG[,colSums(counts(sceG)) &gt; 0]sceG &lt;- logNormCounts(sceG) sceG &lt;- sceG[,1:100] 然后，我们限制到共同基因：123common &lt;- intersect(rownames(sceM), rownames(sceG))sceM &lt;- sceM[common,]sceG &lt;- sceG[common,] 定义自定义markers SingleR()中的默认marker定义适用于源自bulk RNA-seq 数据的参考。 当使用单细胞数据作为参考时，我们建议您构建自己的marker list。这涉及标签之间的一系列成对比较，以定义将每个标签与另一个标签区分开的标记，并易于使用*scran*的功能执行。123library(scran)out &lt;- pairwiseTTests(logcounts(sceM), sceM$label, direction=&quot;up&quot;)markers &lt;- getTopMarkers(out$statistics, out$pairs, n=10) 然后，我们SingleR()通过genes=参数直接提供这些基因。与默认方法相比，更加集中的基因集还可以更快地执行注释。12pred &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, genes=markers)table(pred$labels) 输出：12acinar beta delta duct pp unclear 59 4 1 34 1 1 在某些情况下，markers可能仅可用于特定标签，而不能用于标签之间的成对比较pairwise comparisons。通过向genes提供字符向量的命名列表来解决此问题。 请注意，由于有关成对pairwise的差异（pairwise differences）的信息已被丢弃，这可能不如列表list-of-lists方法强大。 1234567891011&gt; label.markers &lt;- lapply(markers, unlist, recursive=FALSE)&gt; pred2 &lt;- SingleR(test=sceG, ref=sceM, labels=sceM$label, genes=label.markers)&gt; table(pred$labels, pred2$labels) acinar beta delta duct ppacinar 53 0 0 6 0beta 0 4 0 0 0delta 0 0 1 0 0duct 0 0 0 34 0pp 0 0 0 0 1unclear 0 0 0 1 0 三、注释结果检验 根据细胞内的打分 plotScoreHeatmap()显示所有参考标签上所有细胞的分数，这使用户可以检查整个数据集中预测标签的置信度。我们还可以通过设置clusters=或annotation_col=来显示每个细胞的聚类（或其他元数据信息）。 这里，我们显示细胞来自哪个供体以及分配给每个细胞的标签。 123plotScoreHeatmap(pred, show.labels = TRUE, annotation_col=data.frame(donor=sceG$donor, row.names=rownames(pred))) 对于此图，关键是检查每个细胞内分数的分布。理想情况下，每个细胞（即列）应具有一个明显比其余细胞更大的分数，表明它已明确分配给单个标签。给定细胞的相似分数分布表明该分配是不确定的。2. 基于细胞的增量 the deltas across cells pruneScores()函数将删除潜在的质量低下或模棱两可的分配。具体而言，基于每个细胞的增量（即：已分配标签的得分与每个细胞所有标签的中位数之间的差）来识别歧义分配。 低增量表示分配是不确定的。如果参考中不存在细胞的真实标签，则这尤其重要。使用基于异常值的方法来确定用于修剪的确切阈值，该方法考虑了各种情况下相关程度的差异。1234&gt; to.remove &lt;- pruneScores(pred)&gt; summary(to.remove) Mode FALSE logical 100 默认情况下，SingleR()还将报告被修剪的标签，该标签的低质量的分配被替换为NA。 但是，默认修剪阈值可能不适用于每个数据集。?pruneScores有关详细讨论，请参见。 我们还提供plotScoreDistribution()来帮助确定阈值是否合适。这将显示每个细胞之间的中位数差异的每个标签的分布，由此pruneScores()定义一个适当的阈值，即低于中位数的3个中位数绝对偏差（MADs）。1plotScoreDistribution(pred, show = &quot;delta.med&quot;, ncol = 3, show.nmads = 3) 如果必须调整某些调整参数，我们可以直接使用调整后的参数直接调用pruneScores()。在这里，我们如果要将它们丢弃，则将标签设置为NA，这也是SingleR()在pruned.labels中标记此类标签的方式。1234567&gt; new.pruned &lt;- pred$labels&gt; new.pruned[pruneScores(pred, nmads=5)] &lt;- NA&gt; table(new.pruned, useNA=&quot;always&quot;)new.prunedacinar beta delta duct pp unclear &lt;NA&gt; 59 4 1 34 1 1 0 基于Marker基因表达另一个简单而有效的诊断方法是检查测试数据集中每个标签的Marker基因的表达。我们从SingleR结果的metadata中提取markers的identity ，并将其用于*scater*的plotHeatmap()函数中，如下所示用于beta细胞标记。123# Beta cell-related markersplotHeatmap(sceG, order_columns_by=list(I(pred$labels)), features=unique(unlist(metadata(pred)$de.genes$beta))) 我们可以通过将代码包装在一个循环中来对所有标签执行此操作，如下所示：1234for (lab in names(metadata(pred)$de.genes)) { plotHeatmap(sceG, order_columns_by=list(I(pred$labels)), features=unique(unlist(metadata(pred)$de.genes[[lab]]))) } 如果将测试数据集中的某个细胞确信地分配给特定标签，则我们希望它对该标签的markers具有强烈的表达。至少，它应该表现出相对于分配给其他标签的细胞，那些marker的上调。如果不是这种情况，则必须对分配的质量表示怀疑。 四、可用参考集 五、高级使用高级用户可以将SingleR()工作流程分为两个单独的训练和分类步骤。这意味着训练（例如marker检测，最近邻居索引的组装）仅需要执行一次。然后，只要测试特征集与训练集中的特征相同，或是训练集中特征的超集，就可以在具有不同测试数据集的多个分类 classifications 中重复使用所得的数据结构。例如： 123trained &lt;- trainSingleR(sceM, labels=sceM$label, genes=markers)pred2b &lt;- classifySingleR(sceG, trained)table(pred$labels, pred2b$labels) 1234567 acinar beta delta duct pp unclearacinar 59 0 0 0 0 0beta 0 4 0 0 0 0delta 0 0 1 0 0 0duct 0 0 0 34 0 0pp 0 0 0 0 1 0unclear 0 0 0 0 0 1 通过几个参数还可以提高效率： trainSingleR()通过*BiocNeighbors*包中的BNPARAM=参数切换到最接近的邻近索引的近似算法。 classifySingleR()与*BiocParallel*软件包中的BPPARAM=参数并行进行微调步骤。 这些参数也可以在SingleR()命令中指定。 现在才发现的点：SingleR1.1.1其实也就比原本的SingleR1.0.0多了几个下载参考数据集的函数，其他函数都相同。除了不再支持CreateSinglerSeuratObject()函数","link":"/2020/02/06/%E3%80%90%E5%8D%95%E7%BB%86%E8%83%9E%E8%BD%AC%E5%BD%95%E7%BB%849%E3%80%91%E6%96%B0%E7%89%88SingleR1-1-1%E7%BB%86%E8%83%9E%E6%B3%A8%E9%87%8A%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%93%8D/"}],"tags":[],"categories":[]}